// ====================================================================================================
// DNN Subscribo for Second Life
// Â© 2017 dnnsoftware.com
//      v1.0 : 2017 May 10 
// ====================================================================================================


// Constants and global variables ---------------------------------------------------------------------

integer FACESUBSCRIBE = 0;
integer FACEUNSUBSCRIBE = 1;
integer FACEWEBSITE = 3;
integer g_iFace;

string URLDNNSOFTWARE = "http://www.dnnsoftware.com/";
string TGTDOMAIN = "https://dnnapi.com/content/api";
string DNNCONTENTTYPEID = "00000000-0000-0000-0000-000000000000";
string DNNCONTENTTYPENAME = "SL User";

list BASIC_HTTP_PARAMETERS = [
    HTTP_MIMETYPE, "application/json",
    HTTP_BODY_MAXLENGTH, 16384,   // max length for Mono
    HTTP_PRAGMA_NO_CACHE, TRUE,
    HTTP_CUSTOM_HEADER, "Authorization", "Bearer 00000000000000000000000000000000"
    ];

string MAILANNOUNCEMENTS = "announcements";

list VALUESTOSUBSCRIBE = [
    "description", " This is an updated description.", 1,
    "details,subscriptions", MAILANNOUNCEMENTS, 1
];
list VALUESTOWITHDRAW = [
    "details,subscriptions", MAILANNOUNCEMENTS, -1
];
list g_lValuesToUpdate = VALUESTOSUBSCRIBE;

string MSGADDED = "You have been successfully subscribed.";
string MSGREMOVED = "You have been unsubscribed.";
string g_sSuccessMsg = "";

string g_sUserJson;

string t_kDNNID;
string t_kUserUUID;
string t_sUsername;
key t_kHttpReqGet;
key t_kHttpReqPut;
key t_kHttpReqPost;

float WAITSECS = 60.0;


// Functions ------------------------------------------------------------------------------------------


// Notifies with only an OK button.
notifyUser( key kUser, string msg )  {
    llDialog( kUser, msg, [ "OK" ], -123456789 );
}


// Source: http://wiki.secondlife.com/wiki/LlGetRegionName
string wwGetSLUrl()
{
    string globe = "http://maps.secondlife.com/secondlife";
    string region = llGetRegionName();
    vector pos = llGetPos();
    string posx = (string)llRound(pos.x);
    string posy = (string)llRound(pos.y);
    string posz = (string)llRound(pos.z);
    return (globe + "/" + llEscapeURL(region) +"/" + posx + "/" + posy + "/" + posz);
}


// Returns a string to be used as the body of a POST or a PUT.
string createBody( key kUUID, string sName, string sMailList )  {

    list lDetails = [
        "sLUUID", (string) kUUID,
        "subscriptions", sMailList
    ];

    list lCreatedBy = [
        "id", "",
        "name", llGetObjectName() + " at " + wwGetSLUrl(),
        "thumbnail", ""
    ];

    list lTags = [
        "SL",
        "Second Life"
    ];

    list lKeywords = [];

    list lImage = [
        "fileName", "",
        "fileId", 0,
        "url", "http://dnn8bml4l.qa.evoqondemand.com/e91-624-1/DnnImageHandler.ashx?mode=profilepic&userId=1&h=64&w=64"
    ];

     list lSeoSettings = [
        "pageTitle", sName,
        "description", "Second Life subscriber in DNN Liquid Content",
        "keywords", llList2Json( JSON_ARRAY, lKeywords ),
        "image", llList2Json( JSON_OBJECT, lImage )
     ];

    list lRet = [
        "id", "",
        "slug", sName,
        "contentTypeId", DNNCONTENTTYPEID,
        "contentTypeName", DNNCONTENTTYPENAME, 
        "name", sName,
        "description", "",
        "details", llList2Json( JSON_OBJECT, lDetails ),
        "language", "en",
        "alreadyPublished", "true",
        "currentVersion", 1,
        "usages", 0,
        "createdAt", llGetTimestamp(),
        "createdBy", llList2Json( JSON_OBJECT, lCreatedBy ),
        "updatedAt", "",
        "updatedBy", "",
        "stateId", 0,
        "tags", llList2Json( JSON_ARRAY, lTags ),
        "clientReferenceId", "",
        "seoSettings", llList2Json( JSON_OBJECT, lSeoSettings )
    ];

    return( llList2Json( JSON_OBJECT, lRet ) );
}


// Accepts a JSON string and returns it with updated info to use as the body of a PUT.
// lKeyValuePairs is a strided list, where each stride contains:
//  * key - A comma-separated string of the components to the correct node.
//  * value - The new value for the key.
//  * action - 0 to override; 1 to append the new value, separated by a comma; -1 to remove the value.
// Unmentioned nodes are retained as is.
string updateBody( string sJson, list lKeyValuePairs )  {
    list lPath;
    list lOldVal;
    string sOldVal;
    string sNewVal;
    integer iAct;
    integer index;
    integer i;
    integer iCount = llGetListLength( lKeyValuePairs );
    for ( i = 0; i < iCount; i += 3 )  {
        lPath = llParseString2List( llList2String( lKeyValuePairs, i ), [","], [] );
        sNewVal = llList2String( lKeyValuePairs, i + 1 );
        iAct = llList2Integer( lKeyValuePairs, i + 2 );
        
        sOldVal = llJsonGetValue( sJson, lPath );
        if (( iAct != 0 ) && ( sOldVal != "" )) {
            // Get the old value.
            lOldVal = llJson2List( sOldVal );
            
            // Is the new value already there?
            index = llListFindList( lOldVal, [ sNewVal ] );
            
            // Append if not yet in lOldVal. If already there, no need do anything.
            if ( iAct == 1 )  {
                if ( index == -1 )  {
                    lOldVal += [ sNewVal ];
                    sNewVal = llList2Json( JSON_ARRAY, lOldVal );
                }
            }
            
            // Remove from lOldVal. If not there, no need to do anything.
            else if ( iAct == -1 )  {
                if ( index > -1 )  {
                    lOldVal = llDeleteSubList( lOldVal, index, index );
                    sNewVal = llList2Json( JSON_ARRAY, lOldVal );
                }
            }
        }
        sJson = llJsonSetValue( sJson, lPath, sNewVal );
    };
    return(sJson);
}


// Returns the record (as JSON string) of the "SL User" content item that matches the specified key and value.
string getRecord( string sBody, list lKeyPath, string sValue )  {
    string sItems = llJsonGetValue( sBody, [ "documents" ] );
    string sCurrItem;
    list lItems = llJson2List( sItems );
    integer i;
    for ( i = 0; i < llGetListLength( lItems ); i++ )  {
        sCurrItem = llList2String( lItems, i );
        if ( sValue == llJsonGetValue( sCurrItem, lKeyPath ) )  {
            return( sCurrItem );
        }
    }
    return( "" );
}



// States ---------------------------------------------------------------------------------------------

default
{
    state_entry()  {
        state waiting;
    }

}

state waiting {
    touch_end( integer n )  {
        // Who touched?
        t_kUserUUID = llDetectedKey( 0 );
        t_sUsername = llGetUsername( t_kUserUUID );

        // Which side was touched?
        g_iFace = llDetectedTouchFace( 0 );
        if ( g_iFace == FACESUBSCRIBE )  {
            g_lValuesToUpdate = VALUESTOSUBSCRIBE;
            g_sSuccessMsg = MSGADDED;
            state userget;
        }

        else if ( g_iFace == FACEUNSUBSCRIBE )  {
            g_lValuesToUpdate = VALUESTOWITHDRAW;
            g_sSuccessMsg = MSGREMOVED;
            state userget;
        }

        else // if ( g_iFace == FACEWEBSITE ) or any other side.
            llLoadURL( t_kUserUUID, "DNN Software corporate website", URLDNNSOFTWARE );
    }
}

// Check if the user already exists with a GET.
state userget {
    state_entry()  {
        g_sUserJson = "";
        t_kHttpReqGet = llHTTPRequest(
            TGTDOMAIN + "/ContentItems?name=" + (string) t_sUsername,
            BASIC_HTTP_PARAMETERS + [ HTTP_METHOD, "GET" ],
            "" );
        llSetTimerEvent( WAITSECS );
    }

    http_response( key request_id, integer status, list metadata, string body )  {
        if ( request_id == t_kHttpReqGet )  {
            llSetTimerEvent( 0 );

            // Parse the response.
            if (( status >= 200 ) && ( status < 300 ))  {

                // Look for the node under "documents" where "name" == t_sUsername
                g_sUserJson = getRecord( body, [ "name" ], t_sUsername );

                // If found.
                if ( g_sUserJson != "" )  {

                    // Extract the important information.
                    t_kDNNID = llJsonGetValue( g_sUserJson, [ "id" ] );
                    string sName = llJsonGetValue( g_sUserJson, [ "name" ] );
                    string sUUID = llJsonGetValue( g_sUserJson, [ "details", "sLUUID" ] );

                    state userput;
                }

                // If the user does not exist, create a new content item with a POST.
                else
                    state userpost;
            }
            
            // If something went wrong.
            else  {
                notifyUser( t_kUserUUID, "Something went wrong. Please try again. (GET status: " +  (string) status + ")" );
                llOwnerSay( "DEBUG: message body (GET): \n" + body );
                state waiting;
            }
        }
    }

    timer()  {
        notifyUser( t_kUserUUID, "The server did not respond within " + (string) WAITSECS + " seconds. Please try again." );
        llSetTimerEvent( 0 );
        state waiting;
    }

    state_exit()  {
        llSetTimerEvent( 0 );
    }
}


// Create a new SL User content item with a POST.
state userpost {
    state_entry()  {
        string sPostStr = createBody( t_kUserUUID, t_sUsername, MAILANNOUNCEMENTS );

        t_kHttpReqPost = llHTTPRequest(
            TGTDOMAIN + "/ContentItems?publish=true",
            BASIC_HTTP_PARAMETERS + [ HTTP_METHOD, "POST" ],
            sPostStr );
        llSetTimerEvent( WAITSECS );
    }

    http_response( key request_id, integer status, list metadata, string body )  {
        if ( request_id == t_kHttpReqPost )  {
            llSetTimerEvent( 0 );

            // If successful.
            if (( status >= 200 ) && ( status < 300 ))
                notifyUser( t_kUserUUID, g_sSuccessMsg + " (POST status: " +  (string) status + ")" );
            
            // If something went wrong.
            else {
                notifyUser( t_kUserUUID, "Something went wrong. Please try again. (POST status: " +  (string) status + ")" );
                llOwnerSay( "DEBUG: message body (POST): \n" + body );
            }
            
            state waiting;
        }
    }

    timer()  {
        notifyUser( t_kUserUUID, "The server did not respond within " + (string) WAITSECS + " seconds. Please try again." );
        llSetTimerEvent( 0 );
        state waiting;
    }

    state_exit()  {
        llSetTimerEvent( 0 );
    }
}


// Update an existing SL User content item with a PUT.
state userput {
    state_entry()  {
        // Get the record of the specific user.
        t_kHttpReqGet = llHTTPRequest(
            TGTDOMAIN + "/ContentItems/" + t_kDNNID,
            BASIC_HTTP_PARAMETERS + [ HTTP_METHOD, "GET" ],
            "" );
        llSetTimerEvent( WAITSECS );
    }

    http_response( key request_id, integer status, list metadata, string body )  {
        // Handle the response to the specific GET.
        if ( request_id == t_kHttpReqGet )  {
            llSetTimerEvent( 0 );

            // If we got the specific user's info, make updates then PUT.
            if (( status >= 200 ) && ( status < 300 ))  {
                g_sUserJson = body;
                t_kDNNID = llJsonGetValue( g_sUserJson, [ "id" ] );

                string sPostStr = updateBody( g_sUserJson, g_lValuesToUpdate );

                t_kHttpReqPut = llHTTPRequest(
                    TGTDOMAIN + "/ContentItems/" + t_kDNNID + "?publish=true",
                    BASIC_HTTP_PARAMETERS + [ HTTP_METHOD, "PUT" ],
                    sPostStr );

                llSetTimerEvent( WAITSECS );
            }

            // If something went wrong.
            else  {
                notifyUser( t_kUserUUID, "Something went wrong. Please try again. (GET SPECIFIC status: " +  (string) status + ")" );
                llOwnerSay( "DEBUG: message body (GET SPECIFIC): \n" + body );
                state waiting;
            }
        }

        // Handle the response to the PUT.
        else if ( request_id == t_kHttpReqPut )  {
            llSetTimerEvent( 0 );

            // If success.
            if (( status >= 200 ) && ( status < 300 ))  {
                notifyUser( t_kUserUUID, g_sSuccessMsg + " (PUT status: " +  (string) status + ")" );
            }

            // If something went wrong.
            else  {
                notifyUser( t_kUserUUID, "Something went wrong. Please try again. (PUT status: " +  (string) status + ")" );
                llOwnerSay( "DEBUG: message body (PUT): \n" + body );
            }

            state waiting;
        }
    }

    timer()  {
        notifyUser( t_kUserUUID, "The server did not respond within " + (string) WAITSECS + " seconds. Please try again." );
        llSetTimerEvent( 0 );
        state waiting;
    }

    state_exit()  {
        llSetTimerEvent( 0 );
    }
}

// ==================================================
